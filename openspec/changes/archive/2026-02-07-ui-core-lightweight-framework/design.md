## Context

Parchment 阅读器的 HAL 层已就绪（epd_driver、gt911、sd_storage），提供了 framebuffer 绘图、触摸读取和 SD 卡访问能力。但目前 `main.c` 是线性的演示代码，没有事件循环、页面管理或触摸手势识别。

本次变更构建 `ui_core` 组件，作为所有上层功能（阅读、书架、设置等）的基础框架。

**约束条件**：
- 显示: 960×540，4bpp 灰度，E-Ink 刷新耗时 ~600ms（GC16 全刷）、~300ms（DU 局部）
- 内存: 8MB PSRAM，framebuffer 约 259KB（960×540/2）
- 触摸: GT911 单点，INT 引脚 (GPIO 48) 下降沿中断通知有数据可读
- 屏幕方向: 竖屏使用（540×960 逻辑分辨率），坐标需要从物理坐标旋转映射

## Goals / Non-Goals

**Goals:**
- 提供事件驱动的主循环，E-Ink 场景下只在有事件时处理，无事件时阻塞等待
- 提供页面栈导航，支持 push/pop/replace，每个页面实现标准生命周期回调
- 统一事件系统，将触摸原始数据转化为语义手势事件（点击、滑动、长按）
- 提供 Canvas 绘图原语，直接操作 framebuffer
- 支持脏区域追踪，尽量使用局部刷新减少用户等待
- 保持极低的内存和代码开销

**Non-Goals:**
- 不实现 widget 系统（按钮、列表、滚动条等），各页面直接用 Canvas API 绘制
- 不实现动画或过渡效果（E-Ink 不适合）
- 不实现多点触摸手势（捏合缩放等）
- 不实现具体页面（boot、library、reading 等属于后续变更）
- 不实现字体渲染（属于 font_engine 组件）

## Decisions

### D1: 中断驱动 + 两任务架构

**选择**: `touch_task`（中断唤醒+触摸读取+手势识别）+ `ui_task`（事件循环+渲染）

**理由**: GT911 的 INT 引脚 (GPIO 48) 在有触摸数据时产生下降沿脉冲。touch_task 通过信号量等待 INT 中断，被唤醒后读取触摸数据并进行手势识别。无触摸时任务阻塞在信号量上，CPU 可以休眠，功耗极低。

手势识别期间（按下→释放之间），touch_task 切换为 20ms 间隔轮询以持续追踪手指移动轨迹，直到手指释放后重新回到中断等待模式。

**替代方案**: 纯轮询 50Hz — 功耗高，CPU 无法休眠；纯中断 — 无法追踪手指持续移动的轨迹。

### D2: 竖屏坐标映射

**选择**: 在 touch_task 中完成坐标旋转，UI 层统一使用竖屏坐标系 (0,0)=左上角，x∈[0,539]，y∈[0,959]

**理由**: 物理屏幕 960×540 横屏，但阅读器竖屏使用。在最底层统一转换后，所有上层代码不需要关心旋转。

**映射关系**: `logical_x = physical_y`, `logical_y = (BOARD_EPD_WIDTH - 1) - physical_x`（根据实际安装方向调整）

### D3: 事件队列容量

**选择**: 队列深度 16 个事件

**理由**: 正常使用下事件产生速率远低于处理速率。16 个事件足够缓冲突发操作（如快速连续点击），同时仅占 16 × sizeof(ui_event_t) ≈ 256B 内存。

### D4: 页面栈深度

**选择**: 最大 8 层

**理由**: 阅读器导航层级有限（library → reading → toolbar → settings），8 层远超实际需求。静态数组实现，不需要动态分配。

### D5: 手势识别策略

**选择**: 基于距离和时间的简单状态机

- 点击: 按下→释放，移动距离 < 20px，持续 < 500ms
- 长按: 按下不释放，超过 800ms
- 滑动: 按下→释放，移动距离 > 40px，根据主方向判断左/右/上/下

**理由**: 足够覆盖阅读器的交互需求，实现简单，不需要引入复杂的手势库。

### D6: Canvas 绘图直接操作 framebuffer

**选择**: Canvas API 直接读写 epd_driver 的 framebuffer 指针，不维护独立缓冲区

**理由**: framebuffer 在 PSRAM 中约 259KB，没有必要再复制一份。ui_core 通过 `epd_driver_get_framebuffer()` 获取指针后直接操作。

### D7: 脏区域合并策略

**选择**: 维护单个脏矩形（bounding box），多个脏区域自动合并为包围矩形

**理由**: E-Ink 局部刷新的最小粒度已经较粗，多区域分别刷新反而增加总刷新时间。合并为一个矩形，单次 `epd_driver_update_area()` 调用即可。如果脏矩形面积超过屏幕 60%，退化为全屏刷新。

## Risks / Trade-offs

- **[手势误判]** → 简单状态机可能在边界情况误判（如缓慢拖动被判为点击）。缓解：阈值可通过 `#define` 调整，后续可根据实测微调。

- **[坐标旋转方向]** → 竖屏映射的具体公式取决于 M5PaperS3 的物理安装方向，需要实机验证。缓解：映射公式集中在一处，易于修正。

- **[刷新闪烁]** → 频繁局部刷新会导致残影积累。缓解：页面可以设置 `full_refresh` 标志强制 GC16 全刷；可在每 N 次局部刷新后自动触发一次全刷。

- **[手势追踪轮询]** → 手指按下期间切换为 20ms 轮询追踪轨迹，但这只在用户实际触摸时发生，无触摸时完全中断驱动，功耗影响极小。
